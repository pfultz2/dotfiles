#!/usr/bin/python3

import argparse, shutil, shlex, subprocess, os, sys, socketserver, threading, json
__py_dir__ = os.path.normpath(os.path.join(os.path.realpath(__file__), '..', '..', 'py'))
sys.path.append(__py_dir__)
import remote

__commands__ = {}
def command(f):
    __commands__[f.__name__] = f
    return f

@command
def pull(args):
    return remote.pull(args)

@command
def push(args):
    return remote.push(args)

def create_connection_handler(hostname):
    class ConnectionHandler(socketserver.StreamRequestHandler):
        def __init__(self, *args, **kwargs):
             self.hostname = hostname
             super(ConnectionHandler, self).__init__(*args, **kwargs)

        def handle(self):
            data = self.rfile.readline().decode("utf-8").strip()
            args = shlex.split(data)
            if args:
                self.writeline(' '.join(args))
                cmd = args[0]
                f = getattr(self, 'command_' + cmd)
                f(args[1:])

        def get_local(self, path):
            if path.startswith('/'):
                return remote.get_local_path(self.hostname, path)
            return path

        def writeline(self, s):
            self.wfile.write(s.encode('utf-8'))
            self.wfile.write("\n".encode('utf-8'))

        def command_open(self, args):
            f = self.get_local(args[0])
            cmd = [shutil.which('subl')]
            synced = not remote.needs_sync(self.hostname)
            # If it doesnt exists then sync it first
            if not os.path.exists(f):
                synced = True
                remote.pull([f], pipe=self.wfile)
            # Create new window if its a directory
            if os.path.isdir(f):
                cmd.append('-n')
            elif not synced:
                # If its a file then sync it before opening
                remote.pull([f], pipe=self.wfile)
            cmd.append(f)
            self.writeline(' '.join(cmd))
            return subprocess.Popen(cmd, stdout=self.wfile, stderr=self.wfile)

        def get_local_args(self, args):
            return [self.get_local(arg) for arg in args]

        def command_pull(self, args):
            largs = self.get_local_args(args)
            remote.push(largs, pipe=self.wfile)

        def command_push(self, args):
            largs = self.get_local_args(args)
            remote.pull(largs, pipe=self.wfile)

    return ConnectionHandler

class TCPServer(socketserver.ThreadingTCPServer):
    allow_reuse_address = True

def start_server(host):
    server = TCPServer(('localhost', 52697), create_connection_handler(host))
    threading.Thread(target=server.serve_forever, args=[]).start()
    return server

def bash_command():
    return ['env', 'RMATE_PORT=52698', 'SUBLIME_REMOTE_PORT=52697', '$SHELL', '-il']

def connect_et(host, no_terminal=False):
    result = [shutil.which('et'), '-r', '52697:52697,52698:52698']
    if no_terminal:
        result.append('--no-terminal')
        result.append('-x')
    else:
        result.append('-c')
        # Add a space so the command is not added to bash history
        result.append(' ' + ' '.join(bash_command()))
    result.append(host)
    return result

def connect_mosh(host):
    return [shutil.which('mosh'), '--', host] + bash_command()

def connect_ssh(host):
    return [shutil.which('ssh'), '-t', '-R', '52697:localhost:52697', '-R', '52698:localhost:52698', host] + bash_command()

@command
def et(args):
    host = args[0]
    server = start_server(host)
    r = subprocess.run(connect_et(host)).returncode
    server.shutdown()
    return r

@command
def ssh(args):
    host = args[0]
    server = start_server(host)
    r = subprocess.run(connect_ssh(host)).returncode
    server.shutdown()
    return r

@command
def mosh(args):
    host = args[0]
    server = start_server(host)
    etp = subprocess.Popen(connect_et(host, no_terminal=True))
    cp = subprocess.run(connect_mosh(host))
    server.shutdown()
    etp.kill()
    return cp.returncode

@command
def mount(args):
    print(json.dumps(remote.get_mounts()))
    return 0

if __name__ == "__main__":
    cmd = sys.argv[1]
    r = __commands__[cmd](sys.argv[2:])
    exit(r)

